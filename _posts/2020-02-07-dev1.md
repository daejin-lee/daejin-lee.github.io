---
layout: post
title:  "kill 명령어와 Signal"
date:   2021-02-07
author: 이대진
categories: Dev
tags: kill
---

Signal이란 Thread 또는 Process에게 정보를 전달할 때 사용하는 신호를 말한다. 리눅스에서는 사용자 Signal을 포함하여 다양한 신호를 사용할 수 있도록 하고 있다.

linux에서 signal을 보낼 수 있는 대표적인 방법은 `kill` 명령어를 사용하는 것인데, 명령어의 이름이 `kill`이다보니 종종 이 명령어가 프로세스를 종료할 때 사용하는 명령어라고 착각하는 경우가 있다. 물론 나도 처음 `kill`을 사용했을 때는 단순히 프로세스를 종료할 때나 사용했었고, 그래서 명령어 이름이 `kill`이라고 생각했지만... 공부를 하다보니 `kill` 명령어에는 프로세스를 죽이는 것 이외에도 다양한 기능이 있다는 것을 알게 되어, 이 글을 보는 다른 사람들도 `kill` 명령어를 좀 더 잘 활용했으면 하는 마음에 글을 작성한다.

### kill -SIGKILL 로 프로세스 종료하기

먼저 프로세스를 죽이는 것부터 시작하자.

무한 루프를 도는 프로그램을 실행하여 `ps` 명령어로 pid를 확인한다.<br>
무한 루프 프로그램은 아래와 같이 간단하게 작성히였다.

```c
#include <stdio.h>
#include <unistd.h>

int main(void){
    while(1) sleep(1);
    return 0;
}
```

작성한 프로그램을 실행하면 무한 루프를 돌며 프로그램이 실행된다.

![무한 루프 프로그램 실행](https://github.com/daejin-lee/daejin-lee.github.io/blob/Centrarium/assets/images/2020-02-07-dev1/001.png?raw=true)

ps 명령어를 사용하여 pid를 확인할 수 있다.

![ps 명령어 실행](https://github.com/daejin-lee/daejin-lee.github.io/blob/Centrarium/assets/images/2020-02-07-dev1/002.png?raw=true)

알아낸 pid에 kill 명령어로 kill 시그널을 보내는 방법은 간단하다.<br>
`kill -SIGKILL -pid`

![kill 명령어 실행](https://github.com/daejin-lee/daejin-lee.github.io/blob/Centrarium/assets/images/2020-02-07-dev1/003.png?raw=true)

kill 시그널을 전송받은 프로세스는 종료된다.

![kill 명령어 실행 결과](https://github.com/daejin-lee/daejin-lee.github.io/blob/Centrarium/assets/images/2020-02-07-dev1/004.png?raw=true)

여기까지가 일반적으로 kill 명령어를 사용하는 방법일것이라고 생각한다.
하지만 개인적으로는 kill 명령어를 이런 식으로 사용하는 것을 권장하지 않는다.

### Interrupt와 ISR

길을 조금 돌아간다는 느낌이 들지도 모르겠지만, `kill`명령어에 대해 이야기 하기 전에 Interrupt에 대한 이야기를 하려고 한다.

인터럽트란 CPU가 프로그램을 실행하고 있을 때 예외 상황이 발생하여 하던 일을 멈추고 해당 일을 처리하도록 하는 것을 말한다. 업무를 보다가 전화가 울리는 것, 게임을 하다가 여자친구가 부르는 것 모두 인터럽트다. 인터럽트가 발생하면 하던 업무를 잠시 멈추고 전화를 받고, 게임을 잠시 멈추고 여자친구한테 달려간다
(달려가지 않아도 상관없지만 뒷 일은 책임지지 않는다.)

이처럼 인터럽트가 발생하면 정해진 행동을 수행하게 되는데, 이를 ISR(Interrupt Service Routine)이라 한다.
다시 본론으로 돌아오면, Signal은 Linux에서 프로세스에게 보내는 소프트웨어 인터럽트이다. kill 명령어를 통해 특정 프로세스에 Signal을 보내면 프로세스는 사전에 정의된 ISR에 따라 인터럽트를 처리하고, 프로그램을 재개한다.

### kill -SIGKILL? kill -9?

앞서 `kill` 명령어를 `kill -SIGKILL` 또는 `kill -9`처럼 사용하는 것을 권장하지 않는다고 서술하였는다.
그 이유를 설명하기 전에 이 내용은 [정광섭님의 블로그](https://www.lesstif.com/system-admin/unix-linux-kill-12943674.html)를 참고하여 작성되었다는 것을 먼저 밝힌다.

`kill` 명령어를 통해 `KILL` 시그널을 보내서 프로세스를 종료하는 것을 권장하지 않는 이유는 간단하다.
`KILL` 시그널은 인터럽트 핸들러를 등록할 수 없기 때문이다.

프로그램은 실행 중 파일, 소켓, DB 등 다양한 리소스에 접근하여 사용한다.
이 리소스들을 한번이라도 사용해 본 개발자라면 이런 리소스를 사용하는 것 만큼 중요한 것이, 모두 사용한 뒤 리소스를 반환하는 것임을 알고 있을거라 생각한다.

하지만 `kill -9`, `kill -SIGKILL`로 프로세스를 종료하면,
프로세스가 종료되기 전에 수행해야 하는 동작들을 수행하지 않고 강제로 종료된다.

이는 데이터의 유실, DB의 과부하 등 다양한 문제를 수반하기 때문에 `KILL` 시그널로 프로그램을 종료하는 것을 권장하지 않는 것이다.

따라서 프로그램을 종료할 때에는 인터럽트 핸들러를 지정할 수 있는 TERM, INT 등의 시그널을 사용하여 프로그램을 종료해야 하고,
개발자는 위 시그널에 프로그램이 종료될 때 수행해야 하는 동작들을 정의한 cleanup 함수를 정의하여 이를 시그널 핸들러로 등록해야 한다.

### 사용자 정의 시그널

이번에는 사용자 정의 시그널을 통해서 인터럽트 핸들러를 등록하는 방법을 알아본다.
`kill -l` 명령어를 통해 시그널의 종류를 살펴보면
`USR1`, `USR2`라는 시그널을 확인할 수 있다.

![시그널의 종류](https://github.com/daejin-lee/daejin-lee.github.io/blob/Centrarium/assets/images/2020-02-07-dev1/005.png?raw=true)

이 시그널은 사용자 정의 시그널로, 프로세스가 시그널을 받았을 때 개발자가 원하는 동작을 수행하게 할 수 있다.
`USR1` 시그널의 동작을 확인하기 위해 간단하게 사용자 정의 시그널을 받아 동작하는 프로그램을 작성해 보았다. 

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void hello_signal(int num){
    printf("hello signal\n");
}

int main(void){
    signal(SIGUSR1, hello_signal);
    while(1) sleep(1);
    return 0;
}
```

프로그램을 실행한 뒤

![사용자 정의 시그널 프로그램 실행](https://github.com/daejin-lee/daejin-lee.github.io/blob/Centrarium/assets/images/2020-02-07-dev1/006.png?raw=true)

ps 명령어를 사용하여 pid를 확인하여 `SIGUSR1` 시그널을 전송하면

![SIGUSR1 전송](https://github.com/daejin-lee/daejin-lee.github.io/blob/Centrarium/assets/images/2020-02-07-dev1/007.png?raw=true)

위에서 등록한 인터럽트 핸들러가 동작하는 것을 확인할 수 있다.

![사용자 정의 시그널 프로그램](https://github.com/daejin-lee/daejin-lee.github.io/blob/Centrarium/assets/images/2020-02-07-dev1/008.png?raw=true)

이처럼 프로그램에 인터럽트 핸들러를 등록하여 인터럽트가 생겼을 때 실행해야 하는 작업을 정의해주면 좀 더 안전한 프로그램을 만들 수 있다.

결론: SIGKILL 말고 SIGTERM을 사용하자.

끝